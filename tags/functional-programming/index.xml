<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>functional programming on El blog de MagMax</title>
    <link>https://magmax.org/tags/functional-programming/</link>
    <description>Recent content in functional programming on El blog de MagMax</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Jan 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://magmax.org/tags/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Programación funcional</title>
      <link>https://magmax.org/blog/functional-programming/</link>
      <pubDate>Wed, 16 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://magmax.org/blog/functional-programming/</guid>
      <description>
        
          &lt;p&gt;Últimamente se ha puesto de moda la &amp;ldquo;programación funcional&amp;rdquo;. En este artículo voy a intentar explicar lo que es, con ejemplos.&lt;/p&gt;
&lt;p&gt;Parece mentira que siempre volvamos a los orígenes.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://magmax.org/images/functional-programming.png&#34;
         alt=&#34;Functional programming&#34;/&gt; 
&lt;/figure&gt;

&lt;h1 id=&#34;qué-es&#34;&gt;Qué es&lt;/h1&gt;
&lt;p&gt;Existen 3 paradigmas distintos de programación: &lt;strong&gt;estructurada&lt;/strong&gt;, &lt;strong&gt;orientada a objetos&lt;/strong&gt; y &lt;strong&gt;funcional&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;En el jurásico de la informática la gente escribía el código como le venía en gana, usando el famoso &lt;em&gt;GO TO&lt;/em&gt; cada vez que quería reutilizar código. Claro, en esta época había mogollón de ensamblador&amp;hellip; Hasta que llegó &lt;em&gt;Dijstra&lt;/em&gt; y puso un poco de orden, tachando al &lt;em&gt;GO TO&lt;/em&gt; de poco menos que blasfemia.&lt;/p&gt;
&lt;p&gt;Pero&amp;hellip; si no se puede usar el &lt;em&gt;GO TO&lt;/em&gt;, ¿cómo reutilizamos el código? Pues fácil: mediante el uso de funciones. Y así nace la programación &lt;strong&gt;estructurada&lt;/strong&gt;. En mi opinión, esto debería llamarse &amp;ldquo;desestructurada&amp;rdquo; y dejar la estructura para cuando comienzan a utilizarse &lt;strong&gt;TAD&lt;/strong&gt;s (Tipos Abstractos de Datos) pero, en fin, yo no tengo voz ni voto.&lt;/p&gt;
&lt;p&gt;Por esa misma época, quizá incluso algo antes, a alguien se le ocurrió comparar las funciones informáticas con las funciones matemáticas. Pero no se le hizo demasiado caso.&lt;/p&gt;
&lt;p&gt;Dado que todos los programadores terminaban utilizando variables globales para poder almacenar estados, a alguien se le ocurrió que se podían agrupar esos estados con algunas funciones. Y así nació la programación &lt;strong&gt;orientada a objetos&lt;/strong&gt;, que no es más que un &lt;em&gt;TAD&lt;/em&gt; bien organizado.&lt;/p&gt;
&lt;p&gt;Muchos años después, alguien volvió la vista atrás y recordó que otro alguien había pensado en una forma de programar basada en las matemáticas, y decidió echarle un ojo. Y aquéllo no estaba tan mal. La idea era no tener estados (justo lo contrario de la &lt;em&gt;orientación a objetos&lt;/em&gt;), y es lo que se llama &lt;strong&gt;programación funcional&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&#34;en-qué-consiste&#34;&gt;En qué consiste&lt;/h1&gt;
&lt;p&gt;Se trata justamente de eso, de no guardar estados.  La mayor crítica que reciben las técnicas de pruebas es que es &lt;em&gt;difícil&lt;/em&gt;. Probar un objeto que tiene estados es difícil, ya que cualquier alteración en su estado puede provocar que, ante los mismos parámetros, el resultado sea diferente.&lt;/p&gt;
&lt;p&gt;La programación funcional defiende que, si no hay estados, una función debería devolver siempre el mismo resultado ante los mismos parámetros.&lt;/p&gt;
&lt;p&gt;Esto tiene una implicación: la única manera de evitar tener estados es &lt;strong&gt;no utilizar la asignación&lt;/strong&gt;. Si no hay asignaciones, no hay estados.&lt;/p&gt;
&lt;h1 id=&#34;de-verdad-se-puede-programar-así&#34;&gt;¿De verdad se puede programar así?&lt;/h1&gt;
&lt;p&gt;Pues es muy curioso, ya que hay muchos lenguajes que lo soportan: Lisp, Haskell, Erlang, Ruby, Python,&amp;hellip; Algunos de ellos, como Haskell, son funcionales puros. Lisp (acrónimo de &amp;ldquo;&lt;em&gt;LISt Processor&lt;/em&gt;&amp;quot;) trabaja con listas, y lo hace de una manera funcional.&lt;/p&gt;
&lt;p&gt;Debo decir que, habitualmente, resulta complicado de primeras entender un programa escrito de esta manera, aunque a la larga resulta mucho más natural.&lt;/p&gt;
&lt;h1 id=&#34;ponme-un-ejemplo&#34;&gt;Ponme un ejemplo&lt;/h1&gt;
&lt;p&gt;Iba a poner un ejemplo&amp;hellip; Pero he descubierto que puedo poner muchos: todas las funciones &lt;em&gt;built-in&lt;/em&gt; de Python están escritas de esta manera. Sobre todo las de Python 3.&lt;/p&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
